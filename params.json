{
  "name": "Visu algo",
  "tagline": "Framework pour la visualisation d'executions d'algorithmes intéractifs",
  "body": "Framework pour la visualisation d'algorithmes intéractifs\r\n=========================================================\r\n\r\nBase de framework permettant de visualiser en 2D ou 3D l'execution d'un algorithme sur une structure de donnée défini (graphe / arbre / tableau / etc)\r\n\r\n##Technologie utilisée\r\n- C++11\r\n\t- Windows: `MinGW 4.9.1`\r\n\t- Debian sid: `g++ (Debian 4.9.1-19) 4.9.1`\r\n- Qt5.4\r\n\t- Windows: `QtCreator 3.3.1`\r\n\t- Debian sid: `qmake version (5.4.0)`\r\n- OpenGL3.3\r\n\t- `GLSL 330`\r\n- GLM 0.9.6\r\n\t- Manipulation matricielle, pour matrice projection/model/view\r\n- GSL 1.16\r\n\t- Pour le calcul des valeurs/vecteurs propres pour la méthode spectral graph drawing\r\n\r\n####Description\r\n\r\n>les algorithmes semi ou complètement intéractifs permettent de combiner les connaissances d'un expert aux capacités de calcul d'une machine pour solutionner un problème. Le but de ce projet serait de proposer un framework permettant de mettre en place un algorithme (semi-)intéractif en permettant à l'utilisateur de visualiser son déroulement et agir sur celui-ci aux moments où il l'aura désiré. Pour ce faire, la plateforme proposée devra mettre à disposition de manière générique les moyens de brancher un algorithme sur celui-ci (notion de template) tout en fournissant les représentations standard de solution (graphe, arbre, vecteur, ...) pour visualisation mais aussi les briques pour en créer d'autres. Il faudra bien sûr réfléchir à l'ergonomique de l'affichage pour le déroulement de l'algorithme (pas à pas, taux de rafraichissement, ...).\r\n\r\n####Rendu\r\n\r\n#####Vidéo\r\n- [DFS sur un graphe](https://raw.githubusercontent.com/hadjiszs/Visu_algo/master/demo/billboard.webm)\r\n- [Autres](https://github.com/hadjiszs/Visu_algo/tree/master/demo)\r\n\r\n#####Image\r\n![DFS](http://i.imgur.com/cTnOiS6.png)\r\n\r\nMode d'emploi\r\n====\r\n\r\n##Exemple de structure de fichier de graphe\r\n\r\n```\r\nnSommets 12\r\noriente 0\r\nvalue 0\r\ncomplet 0\r\ndebutDefAretes\r\n0 1\r\n0 5\r\n1 2\r\n1 5\r\n2 3\r\n3 6\r\n3 7\r\n4 5\r\n5 6\r\n5 9\r\n9 10\r\n10 11\r\nfinDefAretes\r\n```\r\n\r\n- `nSommets` : nombre de sommets total\r\n- `oriente` : indique si le graphe est orienté\r\n- `value` : indique si les arêtes du graphe sont pondérées\r\n- `complet` : indique si le graphe est complet\r\n- `X Y` : arête entre le nœud X et Y\r\n- `finDefAretes` : fin de la définition des arêtes\r\n\r\n>*NB*: Les informations d'en-tête ne sont pas tout gérés, elles sont présentes mais pas nécessairement prises en compte dans l'avancement actuel du projet.\r\n\r\n###Compilation\r\n####Linux\r\n\r\n```\r\nqmake --version\r\n```\r\nDoit être > 5.4 pour l'utilisation de `QOpenGLWidget` entre autres\r\n\r\n```\r\nqmake compile.pro\r\nmake\r\n```\r\nGénération du makefile puis compilation\r\n\r\n```\r\nexport LC_NUMERIC=C\r\n```\r\nAu cas où Qt aurait modifié le locale\r\n\r\nLes warnings de compilation que l'on peut voir sur [cette compilation](https://asciinema.org/a/20182) sont liés à `GLM`.\r\n\r\n####Windows 7\r\nPour compiler sur Windows, il faut télécharger la version de QCreator cité au début. Puis importer le fichier `compile.pro` pour y créer un nouveau projet.\r\n\r\nIl faut ensuite avoir une version de la GSL portée sur Windows. Beaucoup de problèmes surviennent lors du portage de notre code sur Windows.\r\n\r\nExemple de bug rencontré : la moitiée des arêtes de n'affichent pas correctement\r\n[Exemple ici](http://puu.sh/hsMSR/cb1cbfec57.png)\r\n\r\n##Ajout d'une structure de donnée dans le framework\r\nPour ajouter une nouvelle structure de donnée au framework, il faut créer une nouvelle classe héritant de la classe mère `Structure`. Il faut ensuite impérativement redéfinir les méthodes de chargement (dans lequel il faudra placer dans l'espace les différentes cellules de donnée de la structure).\r\n\r\n###Exemple pour la structure tableau\r\n```\r\nclass Tableau : public Structure {\r\nprivate:\r\n    int tableau[10]; // La structure que l'on veut visualiser\r\n    // herité de la classe Structure :\r\n    // std::vector<SceneVertex> _vertices;\r\n    // std::vector<Etat::Case>  _vertex_to_etat;\r\npublic:\r\n    Tableau(std::string path, TextBox* textbox);\r\n    void charger();\r\n    void parcours();\r\n};\r\n```\r\n\r\nLes valeurs de l'objet `SceneVertex` du vecteur `_vertices` à la position `i` correspond au placement spatiale de la case `i`.\r\nLa valeur `Etat::Case` du vecteur `_vertex_to_etat` à la position `i` correspond au type associé à la case `i`.\r\n\r\nDans la méthode `charger`, il faut donc initialiser ces deux vecteurs à partir du fichier d'entrée.\r\nPour placer les cases de notre tableau dans l'espace, il suffit de placer la case `i` sur l'abscisse `i` tout en laissant à 0 sur les deux autres axes.\r\n\r\n```\r\nvoid Tableau::charger()\r\n{\r\n    _vertices.resize(10);\r\n    for(int i(0); i < 10; i++)\r\n    {\r\n        SceneVertex vertice_courant = { i , 0 , 0 };\r\n        vertices[i] = vertice_courant;\r\n    }\r\n}\r\n```\r\n\r\nChaque valeur de `Etat::Case` est associé à une structure de donnée de visualisation (donnée 3D, couleurs, etc).\r\n\r\nLe vecteur associant l'état à une case est modifiable durant l'exécution de l'algorithme que l'on veut visualiser.\r\n\r\n##Modification du rendu durant l'exécution\r\nPour visualiser un algorithme, il faut donc se placer dans la classe correspondant à la structure utilisée, puis y implémenter une méthode correspondant à notre algorithme.\r\n\r\nExemple en implémentant un simple algorithme de parcours d'un tableau.\r\n\r\n```\r\nvoid Tableau::parcours() {\r\n    for(int i(0); i < 10; i++)\r\n        _vertex_to_etat[i] = Etat::Case::Parcouru;\r\n}\r\n```\r\n\r\nAinsi, durant l'exécution de cet algorithme, nous pourrons voir au fur et à mesure la visualisation des cases parcourus dans la boucle. À chaque itération, nous verrons la case `i` avec les données de visualisation 3D (couleur/modèle 3D etc) correspondant au type `Etat::Case::Parcouru`.\r\n\r\n##Ajout et modification des données de rendu associés aux types\r\nPour ajouter et/ou modifier les données 3D associés aux types, il faut se placer dans `SceneGL::charger_contenu_graphique` se trouvant dans le fichier `scene.cpp`, cette fonction va charger au démarrage toutes les données 3D associés aux types enum.\r\n\r\nPar exemple, il est possible d'ajouter la valeur enum `Etat::Case::Parcouru_Paire` et `Etat::Case::Parcouru_Impaire`. Puis d'y associer les différentes données de visualisation.\r\n\r\n```\r\ninit(Etat::Case::Parcouru_Paire, \"carre3d.dae\", glm::vec3(0.45, 0.45, 0.45), Qt::white, QFont::Monospace);\r\ninit(Etat::Case::Parcouru_Impaire, \"mario3d.dae\", glm::vec3(0.45, 0.0, 0.0), Qt::blue, QFont::Monospace);\r\n```\r\n\r\nDans ce cas de figure, les cases qui seront associées au type `Etat::Case::Parcouru_Paire` se verront être visualisé avec le modèle `carre3d.dae` de couleur gris, et leurs valeurs seront affichés en blanc avec une police de type Monospace.\r\nPour les parcourus impaires, ce sera avec le modèle 3d `mario3d.dae` de couleur rouge, et leurs valeurs seront affichés en bleu avec une police de type Monospace.\r\n\r\nIl est ensuite possible de modifier la méthode de parcours en conséquence. \r\n\r\n```\r\nvoid Tableau::parcours()\r\n{\r\n    for(int i(0); i < 10; i++)\r\n        if(i%2 == 0)\r\n            _vertex_to_etat[i] = Etat::Case::Parcouru_Paire;\r\n        else\r\n            _vertex_to_etat[i] = Etat::Case::Parcouru_Impaire;\r\n}\r\n```\r\n\r\n##Fenêtre de log\r\nPour avoir un suivi personnalisé de l'exécution de l'algorithme, il est possible d'afficher du texte dans une partie de la fenêtre de visualisation.\r\n\r\nLa classe `Tableau` hérite de la classe mère `Structure` qui a un objet de type `TextBox`, cette classe permet de manipuler le texte se trouvant dans une petite fenêtre de la fenêtre principale. \r\n\r\n```\r\nvoid Tableau::parcours()\r\n{\r\n    int num_ligne = _text_box->newline();\r\n    for(int i(0); i < 10; i++)\r\n    {\r\n        // nouvelle iteration\r\n        _text_box->ajouter(\"texte ajouter sur la ligne \\\"num_ligne\\\"\", num_ligne);\r\n        \r\n        if(i%2 == 0)\r\n            _vertex_to_etat[i] = Etat::Case::Parcouru_Paire;\r\n        else\r\n        _vertex_to_etat[i] = Etat::Case::Parcouru_Impaire;\r\n        \r\n        _text_box->remplacer(\"texte remplaçant la ligne \\\"num_ligne\\\" à partir du caractere 0\", num_ligne, 0);\r\n    }\r\n}\r\n```\r\n\r\n##Source de données pour les graphes\r\n###Banque de jolie graphe artistique\r\n- [http://www.cise.ufl.edu/research/sparse/matrices/HB/index.html](http://www.cise.ufl.edu/research/sparse/matrices/HB/index.html)\r\n- [http://www.cise.ufl.edu/research/sparse/matrices/groups.html](http://www.cise.ufl.edu/research/sparse/matrices/groups.html)\r\n\r\n>récupérable sous format MTX, que l'on peut ensuite adapter à notre structure de fichier de graphe.\r\n\r\n###Autres banques de graphe représentant divers tas d'informations\r\n- [http://konect.uni-koblenz.de/networks/](http://konect.uni-koblenz.de/networks/)\r\n- [http://networkrepository.com/index.php](http://networkrepository.com/index.php)\r\n- [http://snap.stanford.edu/data/](http://snap.stanford.edu/data/)\r\n- [http://www-personal.umich.edu/~mejn/netdata/](http://www-personal.umich.edu/~mejn/netdata/)\r\n- [http://law.di.unimi.it/datasets.php](http://law.di.unimi.it/datasets.php)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}